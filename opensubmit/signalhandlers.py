from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
from django.contrib.auth.models import User, Group
from opensubmit.models import Submission, Course

def ensure_user_groups(user, created):
    if not (user.is_superuser and created):
        return

    from django.contrib.auth.models import Group, Permission

    tutor_perms = ( "add_submission", "change_submission", "delete_submission", 
                    "add_submissionfile", "change_submissionfile", "delete_submissionfile" )
    owner_perms = ( "add_assignment", "change_assignment", "delete_assignment",
                    "add_grading", "change_grading",  "delete_grading",
                    "add_gradingscheme", "change_gradingscheme", "delete_gradingscheme",
                    "add_submission", "change_submission", "delete_submission",
                    "add_submissionfile", "change_submissionfile", "delete_submissionfile",
                    "change_course" )

    tutor_group, created = Group.objects.get_or_create(name="Student Tutors")
    if created:
        tutor_group.permissions = [Permission.objects.get(codename=perm) for perm in tutor_perms]      
        tutor_group.save()  

    owner_group, created = Group.objects.get_or_create(name="Course Owners")
    if created:
        owner_group.permissions = [Permission.objects.get(codename=perm) for perm in owner_perms]
        owner_group.save()

@receiver(post_save, sender=User)
def post_user_save(sender,instance, signal, created, **kwargs):
    """
        Make sure that all neccessary user groups exist and have the right permissions,
        directly after the auth system was installed. We detect this by waiting for the admin 
        account creation.
        The permission objects were already generated by the Django database initialization.
    """
    ensure_user_groups(instance, created)

@receiver(post_save, sender=Submission)
def submission_post_save(sender, instance, **kwargs):
    ''' Several sanity checks after we got a valid submission object.'''
    # Make the submitter an author
    if instance.submitter not in instance.authors.all():
        instance.authors.add(instance.submitter)
        instance.save()
    # Mark all existing submissions for this assignment by these authors as invalid.
    # This fixes a race condition with parallel new submissions in multiple browser windows by the same user.
    # Solving this as pre_save security exception does not work, since we have no instance with valid foreign keys to check there.
    # Considering that this runs also on tutor correction backend activities, it also serves as kind-of cleanup functionality
    # for multiplse submissions by the same students for the same assignment - however they got in here.
    if instance.state == instance.get_initial_state():
        for author in instance.authors.all():
            same_author_subm = User.objects.get(pk=author.pk).authored.all().exclude(pk=instance.pk).filter(assignment=instance.assignment)
            for subm in same_author_subm:
                subm.state = Submission.WITHDRAWN
                subm.save()

@receiver(post_save, sender=Course)
def course_post_save(sender, instance, **kwargs):
    ''' Several sanity checks after we got a valid course object.'''
    # Make globally sure that only tutors and course owners have backend access rights.
    # This relates to both tutor addition and removal.
    # PLease note that inactive courses are still considered here, which means that tutors can access their archived courses still

    # Give all tutor users staff rights and add them to the tutors permission group
    tutors = User.objects.filter(courses_tutoring__isnull=False, is_superuser=False)
    tutor_user_group = Group.objects.get(name='Student Tutors')          # check app.py for the group rights
    tutor_user_group.user_set = tutors
    tutor_user_group.save()
    tutors.update(is_staff=True)

    # Give all course owner users staff rights and add them to the course owners permission group
    owners = User.objects.filter(courses__isnull=False)
    owner_user_group = Group.objects.get(name='Course Owners')          # check app.py for the group rights
    owner_user_group.user_set = owners
    owner_user_group.save()
    owners.update(is_staff=True)

    # Make sure that pure students (no tutor, no course owner, no superuser) have no backend access at all
    pure_students = User.objects.filter(courses__isnull=True, courses_tutoring__isnull=True, is_superuser=False)
    pure_students.update(is_staff=False)

